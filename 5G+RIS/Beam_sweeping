import sys
import time
import serial
import pandas as pd
import socket
import json
import numpy as np
from collections import deque

from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QGridLayout, QPushButton, QLabel, QHBoxLayout
)
from PyQt5.QtCore import QTimer

from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
import matplotlib.pyplot as plt


PATTERN_FILE = "5G_patterns.xlsx"
PORT = '/dev/ttyUSB0'  # <-- Update this if your port is different
BAUD_RATE = 115200
UDP_IP = "127.0.0.1"
UDP_PORT = 55555
CQI_THRESHOLD = 9
CQI_DROP_TIME = 5       # Seconds below threshold before resuming search
CHECK_INTERVAL = 500    # ms
MAX_CQI_POINTS = 100
GRID_SIZE = 16


def hex_to_matrix(hex_str):
    """Convert hex string to 16x16 binary matrix."""
    hex_str = hex_str[3:]  # remove !0X or similar prefix
    matrix = [[0]*16 for _ in range(16)]
    for col in range(16):
        bits = bin(int(hex_str[col*4:(col+1)*4], 16))[2:].zfill(16)
        for row in range(16):
            matrix[row][col] = int(bits[row])
    return matrix

def load_patterns(path):
    """Load RIS patterns from Excel file."""
    df = pd.read_excel(path)
    return df.to_dict(orient='records')

def extract_cqi(json_obj):
    """Extract CQI value recursively from nested JSON."""
    if isinstance(json_obj, dict):
        for k, v in json_obj.items():
            if k.lower() == "cqi":
                return v
            result = extract_cqi(v)
            if result is not None:
                return result
    elif isinstance(json_obj, list):
        for item in json_obj:
            result = extract_cqi(item)
            if result is not None:
                return result
    return None


class PatternVisualizer(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("RIS Pattern Visualizer + CQI Monitor")
        self.resize(800, 700)

        # Pattern & CQI state
        self.patterns = load_patterns(PATTERN_FILE)
        self.pattern_index = 0
        self.cqi_values = deque(maxlen=MAX_CQI_POINTS)
        self.time_stamps = deque(maxlen=MAX_CQI_POINTS)
        self.good_pattern_found = False
        self.good_pattern_start_time = 0
        self.start_time = time.time()
        self.last_pattern_time = time.time()
        self.pattern_hold_time = 5  # seconds to hold each pattern

        # Serial & Socket setup
        try:
            self.ser = serial.Serial(PORT, BAUD_RATE, timeout=1)
        except Exception as e:
            print(f"[ERROR] Could not open serial port {PORT}: {e}")
            sys.exit(1)

        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock.bind((UDP_IP, UDP_PORT))
        self.sock.setblocking(False)

        # GUI Layout
        main_layout = QVBoxLayout()

        # Pattern Grid
        self.grid_layout = QGridLayout()
        self.cells = []
        for r in range(GRID_SIZE):
            row_cells = []
            for c in range(GRID_SIZE):
                btn = QPushButton("")
                btn.setFixedSize(25, 25)
                btn.setEnabled(False)
                btn.setStyleSheet("background-color: white; border: 1px solid #ccc;")
                self.grid_layout.addWidget(btn, r, c)
                row_cells.append(btn)
            self.cells.append(row_cells)
        main_layout.addLayout(self.grid_layout)

        # CQI label
        self.label = QLabel("CQI: --")
        self.label.setStyleSheet("font-size: 16px; font-weight: bold;")
        main_layout.addWidget(self.label)

        # Control button
        btn_layout = QHBoxLayout()
        self.btn_next = QPushButton("Next Pattern")
        self.btn_next.clicked.connect(self.next_pattern)
        btn_layout.addWidget(self.btn_next)
        main_layout.addLayout(btn_layout)

        # Matplotlib Figure for CQI
        self.figure, self.ax = plt.subplots(figsize=(8, 4))
        self.canvas = FigureCanvas(self.figure)
        main_layout.addWidget(self.canvas)

        self.setLayout(main_layout)

        # Timer for CQI + pattern updates
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_cqi_and_pattern)
        self.timer.start(CHECK_INTERVAL)

        # Start first pattern
        self.send_pattern(self.pattern_index)

    def send_pattern(self, index):
        data = self.patterns[index]
        pattern = data['Pattern']
        power = data['Power (dB)']
        print(f"\n[{time.strftime('%H:%M:%S')}] Sending Pattern {index} | Power: {power} dB")

        try:
            self.ser.write((pattern + '\n').encode())
            resp = self.ser.readline().decode().strip()
            if resp:
                print(f"RIS Response: {resp}")
        except Exception as e:
            print(f"Serial error: {e}")

        # Update grid visualization
        matrix = hex_to_matrix(pattern)
        self.update_grid(matrix)

    def update_grid(self, matrix):
        for r in range(GRID_SIZE):
            for c in range(GRID_SIZE):
                color = "green" if matrix[r][c] else "white"
                self.cells[r][c].setStyleSheet(f"background-color: {color}; border: 1px solid #ccc;")

    def next_pattern(self):
        if self.pattern_index + 1 < len(self.patterns):
            self.pattern_index += 1
            self.send_pattern(self.pattern_index)
        else:
            print("All patterns sent.")


    def update_cqi_and_pattern(self):
        cqi_val = None
        try:
            data, _ = self.sock.recvfrom(65536)
            j = json.loads(data.decode("utf-8"))
            cqi_val = extract_cqi(j)
        except BlockingIOError:
            pass
        except Exception as e:
            print(f"[WARN] CQI parse error: {e}")

        # Handle CQI updates
        if cqi_val is not None:
            now = time.time() - self.start_time
            self.cqi_values.append(cqi_val)
            self.time_stamps.append(now)
            self.label.setText(f"CQI: {cqi_val:.1f}")

            # GOOD PATTERN FOUND
            if cqi_val > CQI_THRESHOLD:
                if not self.good_pattern_found:
                    print(f"GOOD PATTERN FOUND (CQI={cqi_val}) at index {self.pattern_index}")
                    self.good_pattern_found = True
                    self.good_pattern_start_time = time.time()
                    self.label.setStyleSheet("font-size:16px; font-weight:bold; color:green;")
                else:
                    # refresh timestamp since CQI is still good
                    self.good_pattern_start_time = time.time()

            # CQI DROPPED BELOW THRESHOLD
            elif self.good_pattern_found:
                if time.time() - self.good_pattern_start_time > CQI_DROP_TIME:
                    print(f"CQI dropped below threshold for >{CQI_DROP_TIME}s (CQI={cqi_val}). Resuming pattern switching.")
                    self.good_pattern_found = False
                    self.label.setStyleSheet("font-size:16px; font-weight:bold; color:orange;")

            self.update_plot()

        # PATTERN SWITCHING (only if not locked)
        current_time = time.time()
        if current_time - self.last_pattern_time >= self.pattern_hold_time:
            if not self.good_pattern_found:
                self.next_pattern()
            self.last_pattern_time = current_time

    def update_plot(self):
        self.ax.clear()
        self.ax.plot(list(self.time_stamps), list(self.cqi_values), color='blue', linewidth=2)
        self.ax.axhline(y=CQI_THRESHOLD, color='red', linestyle='--', linewidth=1)
        self.ax.set_ylim(0, 16)
        if self.time_stamps:
            self.ax.set_xlim(max(0, self.time_stamps[0]), self.time_stamps[-1] + 0.5)
        self.ax.set_xlabel("Time (s)")
        self.ax.set_ylabel("CQI")
        self.ax.set_title("Real-Time CQI Plot")
        self.canvas.draw()

    def closeEvent(self, event):
        self.timer.stop()
        try:
            self.ser.close()
        except Exception:
            pass
        self.sock.close()
        event.accept()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = PatternVisualizer()
    window.show()
    sys.exit(app.exec_())
