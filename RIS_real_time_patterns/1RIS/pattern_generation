import sys
import time
import serial
import numpy as np
import uhd
import pandas as pd
from PyQt5.QtGui import QPixmap, QPainter
from PyQt5.QtWidgets import QApplication, QWidget, QGridLayout, QPushButton, QVBoxLayout, QLabel, QFrame
from PyQt5.QtCore import QTimer, Qt
import os
import csv

PORT = '/dev/ttyUSB0'
BAUD_RATE = 115200
DELAY_BETWEEN_PATTERNS = 100  # milliseconds (for QTimer)

def generate_column_on_off_patterns():
    patterns = []
    for i in range(0,2**16):
        binary = bin(i)[2:].zfill(16)
        hex_pattern = "!0X"
        for bit in binary:
            hex_pattern += "FFFF" if bit == '1' else "0000"
        patterns.append(hex_pattern)
    return patterns

patterns = generate_column_on_off_patterns()

def hex_to_matrix(hex_str):
    hex_str = hex_str[3:]  # Remove !0X
    matrix = [[0] * 16 for _ in range(16)]
    for col in range(16):
        bits = bin(int(hex_str[col*4:(col+1)*4], 16))[2:].zfill(16)
        for row in range(16):
            matrix[row][col] = int(bits[row])
    return matrix

class PatternSender(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("16x16 RIS Pattern Visualizer + Power Meter")
        self.resize(500, 550)
        self.grid_size = 16
        self.pattern_index = 0
        self.ser = serial.Serial(PORT, BAUD_RATE, timeout=2)
        self.patterns = patterns
        self.init_usrp()
        self.init_ui()
        self.pattern_power_log = []
        self.max = -100
        self.rx_gain = 80
        self.settling_delay = 1.5
        self.avg_power = 0
        self.variation = 0.5
        self.samples_per_reading = 3
        self.start_time_global = time.time()
        self.last_pattern_time = time.time()

        self.timer = QTimer()
        self.timer.timeout.connect(self.send_next_pattern)
        self.timer.start(DELAY_BETWEEN_PATTERNS)

        self.var_thresh = 0.5

        self.csv_file = "max_power_log.csv"
        if not os.path.exists(self.csv_file):
            with open(self.csv_file, mode='a', newline='') as file:
                writer = csv.writer(file)
                writer.writerow(["Pattern Index", "Max Power (dB)", "Variation (dB)"])
               

    def init_ui(self):
        layout = QVBoxLayout(self)
        self.grid_layout = QGridLayout()
        self.cells = []

        for row in range(self.grid_size):
            row_cells = []
            for col in range(self.grid_size):
                cell = QPushButton("")
                cell.setFixedSize(25, 25)
                cell.setStyleSheet("background-color: white; border: 1px solid #ccc;")
                cell.setEnabled(False)
                self.grid_layout.addWidget(cell, row, col)
                row_cells.append(cell)
            self.cells.append(row_cells)

        layout.addLayout(self.grid_layout)
        self.power_label = QLabel("Power: -- dB")
        layout.addWidget(self.power_label)
        self.setLayout(layout)
        

    def init_usrp(self):
        self.usrp = uhd.usrp.MultiUSRP()
        self.usrp.set_rx_rate(3e6)
        self.usrp.set_rx_freq(uhd.types.TuneRequest(3.5e9))
        self.usrp.set_rx_gain(80)
        stream_args = uhd.usrp.StreamArgs("fc32", "sc16")
        self.rx_stream = self.usrp.get_rx_stream(stream_args)
        self.num_samps = 4096
        self.recv_buffer = np.zeros(self.num_samps, dtype=np.complex64)
        self.rx_md = uhd.types.RXMetadata()
        cmd = uhd.types.StreamCMD(uhd.types.StreamMode.start_cont)
        cmd.stream_now = True
        self.rx_stream.issue_stream_cmd(cmd)

    def send_next_pattern(self):
        if self.pattern_index >= len(self.patterns):
            self.timer.stop()
            self.ser.close()
            df = pd.DataFrame(self.pattern_power_log)
            df_sorted = df.sort_values(by="Power (dB)", ascending=True)
            df_sorted.to_excel("pattern_power_log_sorted.xlsx", index=False)
            print("Saved sorted results to pattern_power_log_sorted.xlsx")
            self.rx_stream.issue_stream_cmd(
                uhd.types.StreamCMD(uhd.types.StreamMode.stop_cont)
            )
            print("Finished sending all patterns.")
            return

        pattern = self.patterns[self.pattern_index]
        print(f"\nSending Pattern {self.pattern_index + 1}/{len(self.patterns)}:\n{pattern}")
        self.ser.write((pattern + '\n').encode())

        try:
            response = self.ser.readline().decode().strip()
            print(f"RIS Response: {response}")
        except Exception as e:
            print(f"No response or decode error: {e}")

        matrix = hex_to_matrix(pattern)
        self.update_grid(matrix)
        # self.save_grid_image(self.pattern_index)
        time.sleep(self.settling_delay)
        power_readings = []
        for i in range(self.samples_per_reading):
            val = self.measure_power()
            print(f"   [{i+1}] Power: {val:.2f} dB")
            power_readings.append(val)
            time.sleep(0.5)

        power_db = round(sum(power_readings) / len(power_readings), 2)
        var = round(max(power_readings) - min(power_readings), 2)
        
        if power_db > self.max and var <= self.var_thresh:
        	self.max = power_db
        	self.variation = var
        	if 1:
        		with open(self.csv_file, mode='a', newline='') as file:
        			writer = csv.writer(file)
        			writer.writerow([pattern, self.max, self.variation])


        self.power_label.setText(f"Power: {power_db:.2f} dB")
        print(f"Pattern Index {self.pattern_index} Measured Signal Power: {power_db:.2f} dB")
        print(f"Max power found till now {self.max} with {self.variation} dB variation")

        self.pattern_power_log.append({"Pattern Index": self.pattern_index, "Pattern": pattern, "Power (dB)": power_db, "Variation": var})
        df = pd.DataFrame(self.pattern_power_log)
        df.to_excel("pattern_power_log.xlsx", index=False)
        now = time.time()
        time_per_pattern = now - self.last_pattern_time
        self.last_pattern_time = now
        time_passed = now - self.start_time_global
        estimated_total = (time_passed / (self.pattern_index + 1)) * len(self.patterns)

        print(f"Time current this pattern: {time_per_pattern:.2f} s")
        print(f"Time passed: {time_passed/3600:.2f} hrs")
        print(f"Estimated total time: {estimated_total/3600:.2f} hrs")
        self.pattern_index += 1

    def update_grid(self, matrix):
        for row in range(self.grid_size):
            for col in range(self.grid_size):
                color = "green" if matrix[row][col] else "white"
                self.cells[row][col].setStyleSheet(f"background-color: {color}; border: 1px solid #ccc;")

    def save_grid_image(self, index):
        pixmap = QPixmap(self.grid_layout.sizeHint())
        pixmap.fill(Qt.white)
        painter = QPainter(pixmap)
        self.grid_layout.parentWidget().render(painter)

        # Draw power text overlay
        power_db = self.pattern_power_log[-1]['Power (dB)'] if self.pattern_power_log else 0
        painter.setPen(Qt.black)
        painter.setFont(self.font())
        painter.drawText(10, 20, f"Power: {power_db:.3f} dB")

        painter.end()
        filename = f"{power_db:.3f}_dB.png"
        pixmap.save(filename)

    def measure_power(self):
        samples = []
        t_start = time.time()

        while time.time() - t_start < 1.0:
            n = self.rx_stream.recv(self.recv_buffer, self.rx_md, timeout=1.0)
            if n > 0:
                samples.append(np.copy(self.recv_buffer[:n]))

        if samples:
            all_samples = np.concatenate(samples)
            power_linear = np.mean(np.abs(all_samples) ** 2)
            return 10 * np.log10(power_linear) if power_linear > 0 else -np.inf
        else:
            return -np.inf

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = PatternSender()
    window.show()
    sys.exit(app.exec_())
