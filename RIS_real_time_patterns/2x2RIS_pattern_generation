import sys
import time
import serial
import numpy as np
import pandas as pd
import uhd
from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QGridLayout, QPushButton, QLabel
from PyQt5.QtCore import QTimer
import os
import csv

PORT1 = '/dev/ttyUSB4'  # RIS1 (bottom-left)
PORT2 = '/dev/ttyUSB3'  # RIS2 (bottom-right)
PORT3 = '/dev/ttyUSB2'  # RIS3 (top-right) -> mirrored RIS2
PORT4 = '/dev/ttyUSB0'  # RIS4 (top-left)  -> mirrored RIS1
BAUD_RATE = 115200
EXCEL_FILE = "pattern_power_log_16x32_4RIS.xlsx"
DELAY_BETWEEN_PATTERNS = 3000  # ms

def generate_column_patterns():
    patterns = []
    for i in range(2 ** 16):  # generate all 16-bit column combinations
        binary = bin(i)[2:].zfill(16)
        ris1 = ""
        ris2 = ""
        ris1_count = 0
        ris2_count = 0
        for b in binary:
            chunk = "FFFF" if b == '1' else "0000"
            ris1 += chunk
            ris2 += chunk
            if b == '1':
                ris1_count += 1
                ris2_count += 1
        if ris1_count >= 3 and ris2_count >= 3:  # avoid trivial patterns
            full = "!0X" + ris1 + ris2
            patterns.append(full)
    return patterns

def hex_to_matrix_16x32(hex_str):
    hex_str = hex_str[3:]  # remove !0X
    if len(hex_str) != 128:
        raise ValueError(f"Expected 128 hex characters, got {len(hex_str)}")
    matrix = [[0]*32 for _ in range(16)]
    for col in range(32):
        bits = bin(int(hex_str[col*4:(col+1)*4], 16))[2:].zfill(16)
        for row in range(16):
            matrix[row][col] = int(bits[row])
    return matrix

class RISVisualizer(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("16x32 RIS Pattern Visualizer + Power Logger (4 RIS)")
        self.grid_size = (16, 32)
        self.patterns = generate_column_patterns()
        self.pattern_index = 0
        self.pattern_power_log = []
        self.load_existing_excel()

        # Open all 4 RIS serial ports
        self.ser1 = serial.Serial(PORT1, BAUD_RATE, timeout=2)
        self.ser2 = serial.Serial(PORT2, BAUD_RATE, timeout=2)
        self.ser3 = serial.Serial(PORT3, BAUD_RATE, timeout=2)
        self.ser4 = serial.Serial(PORT4, BAUD_RATE, timeout=2)
        self.init_usrp()

        self.max = -100
        self.settling_delay = 3
        self.samples_per_reading = 3
        self.var_thresh = 0.5

        self.csv_file = "max_power_log_4RIS.csv"
        if not os.path.exists(self.csv_file):
            with open(self.csv_file, mode='w', newline='') as file:
                writer = csv.writer(file)
                writer.writerow(["Pattern Index", "Max Power (dB)", "Variation (dB)"])

        self.layout = QVBoxLayout(self)
        self.grid_layout = QGridLayout()
        self.cells = []
    
        for row in range(16):
            row_cells = []
            for col in range(32):
                cell = QPushButton("")
                cell.setFixedSize(20, 20)
                cell.setEnabled(False)
                cell.setStyleSheet("background-color: white;")
                self.grid_layout.addWidget(cell, row, col)
                row_cells.append(cell)
            self.cells.append(row_cells)
        self.layout.addLayout(self.grid_layout)

        self.power_label = QLabel("Power: -- dB")
        self.layout.addWidget(self.power_label)

        self.timer = QTimer()
        self.timer.timeout.connect(self.send_next_pattern)
        self.timer.start(DELAY_BETWEEN_PATTERNS)

    def load_existing_excel(self):
        try:
            df_existing = pd.read_excel(EXCEL_FILE)
            self.pattern_index = len(df_existing)
            print(f"Continuing from pattern index: {self.pattern_index}")
        except:
            print("Starting fresh. No previous log found.")


    def init_usrp(self):
        self.usrp = uhd.usrp.MultiUSRP()
        self.usrp.set_rx_rate(3e6)
        self.usrp.set_rx_freq(uhd.types.TuneRequest(3.5e9))
        self.usrp.set_rx_gain(80)
        stream_args = uhd.usrp.StreamArgs("fc32", "sc16")
        self.rx_stream = self.usrp.get_rx_stream(stream_args)
        self.num_samps = 4096
        self.recv_buffer = np.zeros(self.num_samps, dtype=np.complex64)
        self.rx_md = uhd.types.RXMetadata()
        cmd = uhd.types.StreamCMD(uhd.types.StreamMode.start_cont)
        cmd.stream_now = True
        self.rx_stream.issue_stream_cmd(cmd)




    def measure_power(self):
        samples = []
        t_start = time.time()

        while time.time() - t_start < 1.0:
            n = self.rx_stream.recv(self.recv_buffer, self.rx_md, timeout=1.0)
            if n > 0:
                samples.append(np.copy(self.recv_buffer[:n]))

        if samples:
            all_samples = np.concatenate(samples)
            power_linear = np.mean(np.abs(all_samples) ** 2)
            return 10 * np.log10(power_linear) if power_linear > 0 else -np.inf
        else:
            return -np.inf
        


    def send_next_pattern(self):
        if self.pattern_index >= len(self.patterns):
            print("All patterns sent.")
            self.timer.stop()
            return

        full_pattern = self.patterns[self.pattern_index]
        if len(full_pattern[3:]) != 128:
            print(f"Skipping invalid pattern: {full_pattern}")
            self.pattern_index += 1
            return

        ris1_hex = full_pattern[3:67]  # bottom-left
        ris2_hex = full_pattern[67:]   # bottom-right

        # Send to all 4 RIS
        self.ser1.write(("!0X" + ris1_hex + '\n').encode())  # RIS1 bottom-left
        self.ser2.write(("!0X" + ris2_hex + '\n').encode())  # RIS2 bottom-right
        self.ser3.write(("!0X" + ris2_hex + '\n').encode())  # RIS3 top-right (mirror of RIS2)
        self.ser4.write(("!0X" + ris1_hex + '\n').encode())  # RIS4 top-left  (mirror of RIS1)

        print(f"Pattern {self.pattern_index} sent to 4 RIS")
        matrix = hex_to_matrix_16x32(full_pattern)
        self.update_grid(matrix)

        # Allow RIS to settle before measurement
        time.sleep(self.settling_delay)

        power_readings = []
        for i in range(self.samples_per_reading):
            val = self.measure_power()
            #val=-25
            print(f"   [{i+1}] Power: {val:.2f} dB")
            power_readings.append(val)
            time.sleep(2)

        power = round(sum(power_readings) / len(power_readings), 2)
        var = round(max(power_readings) - min(power_readings), 2)
        matrix = hex_to_matrix_16x32(full_pattern)
        self.update_grid(matrix)

        if power > self.max and var <= self.var_thresh:
            self.max = power
            with open(self.csv_file, mode='a', newline='') as file:
                writer = csv.writer(file)
                writer.writerow([self.pattern_index, self.max, var])

        self.power_label.setText(f"Power: {power:.2f} dB")
        print(f"Pattern Index {self.pattern_index} Measured Power: {power:.2f} dB, Max so far: {self.max}")

        log_entry = pd.DataFrame([{"Index": self.pattern_index, "Pattern": full_pattern, "Power (dB)": power, "Variation": var}])
        try:
            existing = pd.read_excel(EXCEL_FILE)
            updated = pd.concat([existing, log_entry], ignore_index=True)
        except:
            updated = log_entry
        updated.to_excel(EXCEL_FILE, index=False)
        self.pattern_index += 1

    def update_grid(self, matrix):
        for r in range(16):
            for c in range(32):
                color = "green" if matrix[r][c] else "white"
                self.cells[r][c].setStyleSheet(f"background-color: {color};")

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = RISVisualizer()
    window.show()
    sys.exit(app.exec_())
